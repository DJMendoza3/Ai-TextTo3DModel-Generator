{"ast":null,"code":"import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, LoaderUtils, Color } from 'three';\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tconst loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n * Custom properties outside of the defaults for position, uv, normal\n * and color attributes can be added using the setCustomPropertyMapping method.\n * For example, the following maps the element properties “custom_property_a”\n * and “custom_property_b” to an attribute “customAttribute” with an item size of 2.\n * Attribute item sizes are set from the number of element properties in the property array.\n *\n * loader.setCustomPropertyMapping( {\n *\tcustomAttribute: ['custom_property_a', 'custom_property_b'],\n * } );\n *\n */\n\nconst _color = new Color();\nclass PLYLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.propertyNameMapping = {};\n    this.customPropertyMapping = {};\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  setPropertyNameMapping(mapping) {\n    this.propertyNameMapping = mapping;\n  }\n  setCustomPropertyNameMapping(mapping) {\n    this.customPropertyMapping = mapping;\n  }\n  parse(data) {\n    function parseHeader(data) {\n      const patternHeader = /^ply([\\s\\S]*)end_header(\\r\\n|\\r|\\n)/;\n      let headerText = '';\n      let headerLength = 0;\n      const result = patternHeader.exec(data);\n      if (result !== null) {\n        headerText = result[1];\n        headerLength = new Blob([result[0]]).size;\n      }\n      const header = {\n        comments: [],\n        elements: [],\n        headerLength: headerLength,\n        objInfo: ''\n      };\n      const lines = headerText.split(/\\r\\n|\\r|\\n/);\n      let currentElement;\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        const property = {\n          type: propertValues[0]\n        };\n        if (property.type === 'list') {\n          property.name = propertValues[3];\n          property.countType = propertValues[1];\n          property.itemType = propertValues[2];\n        } else {\n          property.name = propertValues[1];\n        }\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name];\n        }\n        return property;\n      }\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === '') continue;\n        const lineValues = line.split(/\\s+/);\n        const lineType = lineValues.shift();\n        line = lineValues.join(' ');\n        switch (lineType) {\n          case 'format':\n            header.format = lineValues[0];\n            header.version = lineValues[1];\n            break;\n          case 'comment':\n            header.comments.push(line);\n            break;\n          case 'element':\n            if (currentElement !== undefined) {\n              header.elements.push(currentElement);\n            }\n            currentElement = {};\n            currentElement.name = lineValues[0];\n            currentElement.count = parseInt(lineValues[1]);\n            currentElement.properties = [];\n            break;\n          case 'property':\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n            break;\n          case 'obj_info':\n            header.objInfo = line;\n            break;\n          default:\n            console.log('unhandled', lineType, lineValues);\n        }\n      }\n      if (currentElement !== undefined) {\n        header.elements.push(currentElement);\n      }\n      return header;\n    }\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n          return parseInt(n);\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n          return parseFloat(n);\n      }\n    }\n    function parseASCIIElement(properties, line) {\n      const values = line.split(/\\s+/);\n      const element = {};\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          const list = [];\n          const n = parseASCIINumber(values.shift(), properties[i].countType);\n          for (let j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n          }\n          element[properties[i].name] = list;\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n        }\n      }\n      return element;\n    }\n    function createBuffer() {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      for (const customProperty of Object.keys(scope.customPropertyMapping)) {\n        buffer[customProperty] = [];\n      }\n      return buffer;\n    }\n    function parseASCII(data, header) {\n      // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n      const buffer = createBuffer();\n      let result;\n      const patternBody = /end_header\\s([\\s\\S]*)$/;\n      let body = '';\n      if ((result = patternBody.exec(data)) !== null) {\n        body = result[1];\n      }\n      const lines = body.split(/\\r\\n|\\r|\\n/);\n      let currentElement = 0;\n      let currentElementCount = 0;\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === '') {\n          continue;\n        }\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++;\n          currentElementCount = 0;\n        }\n        const element = parseASCIIElement(header.elements[currentElement].properties, line);\n        handleElement(buffer, header.elements[currentElement].name, element);\n        currentElementCount++;\n      }\n      return postProcess(buffer);\n    }\n    function postProcess(buffer) {\n      let geometry = new BufferGeometry();\n\n      // mandatory buffer data\n\n      if (buffer.indices.length > 0) {\n        geometry.setIndex(buffer.indices);\n      }\n      geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3));\n\n      // optional buffer data\n\n      if (buffer.normals.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3));\n      }\n      if (buffer.uvs.length > 0) {\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2));\n      }\n      if (buffer.colors.length > 0) {\n        geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3));\n      }\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry = geometry.toNonIndexed();\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n      }\n\n      // custom buffer data\n\n      for (const customProperty of Object.keys(scope.customPropertyMapping)) {\n        if (buffer[customProperty].length > 0) {\n          geometry.setAttribute(customProperty, new Float32BufferAttribute(buffer[customProperty], scope.customPropertyMapping[customProperty].length));\n        }\n      }\n      geometry.computeBoundingSphere();\n      return geometry;\n    }\n    function handleElement(buffer, elementName, element) {\n      function findAttrName(names) {\n        for (let i = 0, l = names.length; i < l; i++) {\n          const name = names[i];\n          if (name in element) return name;\n        }\n        return null;\n      }\n      const attrX = findAttrName(['x', 'px', 'posx']) || 'x';\n      const attrY = findAttrName(['y', 'py', 'posy']) || 'y';\n      const attrZ = findAttrName(['z', 'pz', 'posz']) || 'z';\n      const attrNX = findAttrName(['nx', 'normalx']);\n      const attrNY = findAttrName(['ny', 'normaly']);\n      const attrNZ = findAttrName(['nz', 'normalz']);\n      const attrS = findAttrName(['s', 'u', 'texture_u', 'tx']);\n      const attrT = findAttrName(['t', 'v', 'texture_v', 'ty']);\n      const attrR = findAttrName(['red', 'diffuse_red', 'r', 'diffuse_r']);\n      const attrG = findAttrName(['green', 'diffuse_green', 'g', 'diffuse_g']);\n      const attrB = findAttrName(['blue', 'diffuse_blue', 'b', 'diffuse_b']);\n      if (elementName === 'vertex') {\n        buffer.vertices.push(element[attrX], element[attrY], element[attrZ]);\n        if (attrNX !== null && attrNY !== null && attrNZ !== null) {\n          buffer.normals.push(element[attrNX], element[attrNY], element[attrNZ]);\n        }\n        if (attrS !== null && attrT !== null) {\n          buffer.uvs.push(element[attrS], element[attrT]);\n        }\n        if (attrR !== null && attrG !== null && attrB !== null) {\n          _color.setRGB(element[attrR] / 255.0, element[attrG] / 255.0, element[attrB] / 255.0).convertSRGBToLinear();\n          buffer.colors.push(_color.r, _color.g, _color.b);\n        }\n        for (const customProperty of Object.keys(scope.customPropertyMapping)) {\n          for (const elementProperty of scope.customPropertyMapping[customProperty]) {\n            buffer[customProperty].push(element[elementProperty]);\n          }\n        }\n      } else if (elementName === 'face') {\n        const vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n        const texcoord = element.texcoord;\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n        }\n      }\n    }\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        // corespondences for non-specific length types here match rply:\n        case 'int8':\n        case 'char':\n          return [dataview.getInt8(at), 1];\n        case 'uint8':\n        case 'uchar':\n          return [dataview.getUint8(at), 1];\n        case 'int16':\n        case 'short':\n          return [dataview.getInt16(at, little_endian), 2];\n        case 'uint16':\n        case 'ushort':\n          return [dataview.getUint16(at, little_endian), 2];\n        case 'int32':\n        case 'int':\n          return [dataview.getInt32(at, little_endian), 4];\n        case 'uint32':\n        case 'uint':\n          return [dataview.getUint32(at, little_endian), 4];\n        case 'float32':\n        case 'float':\n          return [dataview.getFloat32(at, little_endian), 4];\n        case 'float64':\n        case 'double':\n          return [dataview.getFloat64(at, little_endian), 8];\n      }\n    }\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      const element = {};\n      let result,\n        read = 0;\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          const list = [];\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n          const n = result[0];\n          read += result[1];\n          for (let j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n            list.push(result[0]);\n            read += result[1];\n          }\n          element[properties[i].name] = list;\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n          element[properties[i].name] = result[0];\n          read += result[1];\n        }\n      }\n      return [element, read];\n    }\n    function parseBinary(data, header) {\n      const buffer = createBuffer();\n      const little_endian = header.format === 'binary_little_endian';\n      const body = new DataView(data, header.headerLength);\n      let result,\n        loc = 0;\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (let currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n          loc += result[1];\n          const element = result[0];\n          handleElement(buffer, header.elements[currentElement].name, element);\n        }\n      }\n      return postProcess(buffer);\n    }\n\n    //\n\n    let geometry;\n    const scope = this;\n    if (data instanceof ArrayBuffer) {\n      const text = LoaderUtils.decodeText(new Uint8Array(data));\n      const header = parseHeader(text);\n      geometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header);\n    } else {\n      geometry = parseASCII(data, parseHeader(data));\n    }\n    return geometry;\n  }\n}\nexport { PLYLoader };","map":{"version":3,"names":["BufferGeometry","FileLoader","Float32BufferAttribute","Loader","LoaderUtils","Color","_color","PLYLoader","constructor","manager","propertyNameMapping","customPropertyMapping","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setPropertyNameMapping","mapping","setCustomPropertyNameMapping","data","parseHeader","patternHeader","headerText","headerLength","result","exec","Blob","size","header","comments","elements","objInfo","lines","split","currentElement","make_ply_element_property","propertValues","property","type","name","countType","itemType","i","length","line","trim","lineValues","lineType","shift","join","format","version","push","undefined","count","parseInt","properties","log","parseASCIINumber","n","parseFloat","parseASCIIElement","values","element","list","j","createBuffer","buffer","indices","vertices","normals","uvs","faceVertexUvs","colors","customProperty","Object","keys","parseASCII","patternBody","body","currentElementCount","handleElement","postProcess","geometry","setIndex","setAttribute","toNonIndexed","computeBoundingSphere","elementName","findAttrName","names","l","attrX","attrY","attrZ","attrNX","attrNY","attrNZ","attrS","attrT","attrR","attrG","attrB","setRGB","convertSRGBToLinear","r","g","b","elementProperty","vertex_indices","vertex_index","texcoord","binaryRead","dataview","at","little_endian","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","binaryReadElement","read","parseBinary","DataView","loc","ArrayBuffer","decodeText","Uint8Array"],"sources":["/Users/daniel/Desktop/OpenAI/ai-frontend/ai-react/node_modules/three/examples/jsm/loaders/PLYLoader.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tLoaderUtils,\n\tColor\n} from 'three';\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tconst loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n * Custom properties outside of the defaults for position, uv, normal\n * and color attributes can be added using the setCustomPropertyMapping method.\n * For example, the following maps the element properties “custom_property_a”\n * and “custom_property_b” to an attribute “customAttribute” with an item size of 2.\n * Attribute item sizes are set from the number of element properties in the property array.\n *\n * loader.setCustomPropertyMapping( {\n *\tcustomAttribute: ['custom_property_a', 'custom_property_b'],\n * } );\n *\n */\n\nconst _color = new Color();\n\nclass PLYLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.propertyNameMapping = {};\n\t\tthis.customPropertyMapping = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tsetPropertyNameMapping( mapping ) {\n\n\t\tthis.propertyNameMapping = mapping;\n\n\t}\n\n\tsetCustomPropertyNameMapping( mapping ) {\n\n\t\tthis.customPropertyMapping = mapping;\n\n\t}\n\n\tparse( data ) {\n\n\t\tfunction parseHeader( data ) {\n\n\t\t\tconst patternHeader = /^ply([\\s\\S]*)end_header(\\r\\n|\\r|\\n)/;\n\t\t\tlet headerText = '';\n\t\t\tlet headerLength = 0;\n\t\t\tconst result = patternHeader.exec( data );\n\n\t\t\tif ( result !== null ) {\n\n\t\t\t\theaderText = result[ 1 ];\n\t\t\t\theaderLength = new Blob( [ result[ 0 ] ] ).size;\n\n\t\t\t}\n\n\t\t\tconst header = {\n\t\t\t\tcomments: [],\n\t\t\t\telements: [],\n\t\t\t\theaderLength: headerLength,\n\t\t\t\tobjInfo: ''\n\t\t\t};\n\n\t\t\tconst lines = headerText.split( /\\r\\n|\\r|\\n/ );\n\t\t\tlet currentElement;\n\n\t\t\tfunction make_ply_element_property( propertValues, propertyNameMapping ) {\n\n\t\t\t\tconst property = { type: propertValues[ 0 ] };\n\n\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\tproperty.name = propertValues[ 3 ];\n\t\t\t\t\tproperty.countType = propertValues[ 1 ];\n\t\t\t\t\tproperty.itemType = propertValues[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tproperty.name = propertValues[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( property.name in propertyNameMapping ) {\n\n\t\t\t\t\tproperty.name = propertyNameMapping[ property.name ];\n\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tlet line = lines[ i ];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif ( line === '' ) continue;\n\n\t\t\t\tconst lineValues = line.split( /\\s+/ );\n\t\t\t\tconst lineType = lineValues.shift();\n\t\t\t\tline = lineValues.join( ' ' );\n\n\t\t\t\tswitch ( lineType ) {\n\n\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\theader.format = lineValues[ 0 ];\n\t\t\t\t\t\theader.version = lineValues[ 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\theader.comments.push( line );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\tcurrentElement.name = lineValues[ 0 ];\n\t\t\t\t\t\tcurrentElement.count = parseInt( lineValues[ 1 ] );\n\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\tcurrentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'obj_info':\n\n\t\t\t\t\t\theader.objInfo = line;\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.log( 'unhandled', lineType, lineValues );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t}\n\n\t\t\treturn header;\n\n\t\t}\n\n\t\tfunction parseASCIINumber( n, type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\n\t\t\t\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\n\n\t\t\t\t\treturn parseInt( n );\n\n\t\t\t\tcase 'float': case 'double': case 'float32': case 'float64':\n\n\t\t\t\t\treturn parseFloat( n );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseASCIIElement( properties, line ) {\n\n\t\t\tconst values = line.split( /\\s+/ );\n\n\t\t\tconst element = {};\n\n\t\t\tfor ( let i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tconst list = [];\n\t\t\t\t\tconst n = parseASCIINumber( values.shift(), properties[ i ].countType );\n\n\t\t\t\t\tfor ( let j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tlist.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\telement[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn element;\n\n\t\t}\n\n\t\tfunction createBuffer() {\n\n\t\t\tconst buffer = {\n\t\t\t  indices: [],\n\t\t\t  vertices: [],\n\t\t\t  normals: [],\n\t\t\t  uvs: [],\n\t\t\t  faceVertexUvs: [],\n\t\t\t  colors: [],\n\t\t\t};\n\n\t\t\tfor ( const customProperty of Object.keys( scope.customPropertyMapping ) ) {\n\n\t\t\t  buffer[ customProperty ] = [];\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t}\n\n\t\tfunction parseASCII( data, header ) {\n\n\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n\t\t\tconst buffer = createBuffer();\n\n\t\t\tlet result;\n\n\t\t\tconst patternBody = /end_header\\s([\\s\\S]*)$/;\n\t\t\tlet body = '';\n\t\t\tif ( ( result = patternBody.exec( data ) ) !== null ) {\n\n\t\t\t\tbody = result[ 1 ];\n\n\t\t\t}\n\n\t\t\tconst lines = body.split( /\\r\\n|\\r|\\n/ );\n\t\t\tlet currentElement = 0;\n\t\t\tlet currentElementCount = 0;\n\n\t\t\tfor ( let i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tlet line = lines[ i ];\n\t\t\t\tline = line.trim();\n\t\t\t\tif ( line === '' ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( currentElementCount >= header.elements[ currentElement ].count ) {\n\n\t\t\t\t\tcurrentElement ++;\n\t\t\t\t\tcurrentElementCount = 0;\n\n\t\t\t\t}\n\n\t\t\t\tconst element = parseASCIIElement( header.elements[ currentElement ].properties, line );\n\n\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\tcurrentElementCount ++;\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\tfunction postProcess( buffer ) {\n\n\t\t\tlet geometry = new BufferGeometry();\n\n\t\t\t// mandatory buffer data\n\n\t\t\tif ( buffer.indices.length > 0 ) {\n\n\t\t\t\tgeometry.setIndex( buffer.indices );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( buffer.vertices, 3 ) );\n\n\t\t\t// optional buffer data\n\n\t\t\tif ( buffer.normals.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( buffer.normals, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.uvs.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( buffer.uvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.colors.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( buffer.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.faceVertexUvs.length > 0 ) {\n\n\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( buffer.faceVertexUvs, 2 ) );\n\n\t\t\t}\n\n\t\t\t// custom buffer data\n\n\t\t\tfor ( const customProperty of Object.keys( scope.customPropertyMapping ) ) {\n\n\t\t\t\tif ( buffer[ customProperty ].length > 0 ) {\n\n\t\t\t\t  \tgeometry.setAttribute(\n\t\t\t\t\t\tcustomProperty,\n\t\t\t\t\t\tnew Float32BufferAttribute(\n\t\t\t\t\t  \t\tbuffer[ customProperty ],\n\t\t\t\t\t  \t\tscope.customPropertyMapping[ customProperty ].length\n\t\t\t\t\t\t)\n\t\t\t\t  \t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction handleElement( buffer, elementName, element ) {\n\n\t\t\tfunction findAttrName( names ) {\n\n\t\t\t\tfor ( let i = 0, l = names.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst name = names[ i ];\n\n\t\t\t\t\tif ( name in element ) return name;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst attrX = findAttrName( [ 'x', 'px', 'posx' ] ) || 'x';\n\t\t\tconst attrY = findAttrName( [ 'y', 'py', 'posy' ] ) || 'y';\n\t\t\tconst attrZ = findAttrName( [ 'z', 'pz', 'posz' ] ) || 'z';\n\t\t\tconst attrNX = findAttrName( [ 'nx', 'normalx' ] );\n\t\t\tconst attrNY = findAttrName( [ 'ny', 'normaly' ] );\n\t\t\tconst attrNZ = findAttrName( [ 'nz', 'normalz' ] );\n\t\t\tconst attrS = findAttrName( [ 's', 'u', 'texture_u', 'tx' ] );\n\t\t\tconst attrT = findAttrName( [ 't', 'v', 'texture_v', 'ty' ] );\n\t\t\tconst attrR = findAttrName( [ 'red', 'diffuse_red', 'r', 'diffuse_r' ] );\n\t\t\tconst attrG = findAttrName( [ 'green', 'diffuse_green', 'g', 'diffuse_g' ] );\n\t\t\tconst attrB = findAttrName( [ 'blue', 'diffuse_blue', 'b', 'diffuse_b' ] );\n\n\t\t\tif ( elementName === 'vertex' ) {\n\n\t\t\t\tbuffer.vertices.push( element[ attrX ], element[ attrY ], element[ attrZ ] );\n\n\t\t\t\tif ( attrNX !== null && attrNY !== null && attrNZ !== null ) {\n\n\t\t\t\t\tbuffer.normals.push( element[ attrNX ], element[ attrNY ], element[ attrNZ ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( attrS !== null && attrT !== null ) {\n\n\t\t\t\t\tbuffer.uvs.push( element[ attrS ], element[ attrT ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( attrR !== null && attrG !== null && attrB !== null ) {\n\n\t\t\t\t\t_color.setRGB(\n\t\t\t\t\t\telement[ attrR ] / 255.0,\n\t\t\t\t\t\telement[ attrG ] / 255.0,\n\t\t\t\t\t\telement[ attrB ] / 255.0\n\t\t\t\t\t).convertSRGBToLinear();\n\n\t\t\t\t\tbuffer.colors.push( _color.r, _color.g, _color.b );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( const customProperty of Object.keys( scope.customPropertyMapping ) ) {\n\n\t\t\t\t\tfor ( const elementProperty of scope.customPropertyMapping[ customProperty ] ) {\n\n\t\t\t\t\t  buffer[ customProperty ].push( element[ elementProperty ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( elementName === 'face' ) {\n\n\t\t\t\tconst vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\t\t\t\tconst texcoord = element.texcoord;\n\n\t\t\t\tif ( vertex_indices.length === 3 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );\n\n\t\t\t\t\tif ( texcoord && texcoord.length === 6 ) {\n\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );\n\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( vertex_indices.length === 4 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryRead( dataview, at, type, little_endian ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\t// corespondences for non-specific length types here match rply:\n\t\t\t\tcase 'int8':\t\tcase 'char':\t return [ dataview.getInt8( at ), 1 ];\n\t\t\t\tcase 'uint8':\t\tcase 'uchar':\t return [ dataview.getUint8( at ), 1 ];\n\t\t\t\tcase 'int16':\t\tcase 'short':\t return [ dataview.getInt16( at, little_endian ), 2 ];\n\t\t\t\tcase 'uint16':\tcase 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];\n\t\t\t\tcase 'int32':\t\tcase 'int':\t\t return [ dataview.getInt32( at, little_endian ), 4 ];\n\t\t\t\tcase 'uint32':\tcase 'uint':\t return [ dataview.getUint32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float32': case 'float':\t return [ dataview.getFloat32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryReadElement( dataview, at, properties, little_endian ) {\n\n\t\t\tconst element = {};\n\t\t\tlet result, read = 0;\n\n\t\t\tfor ( let i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tconst list = [];\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );\n\t\t\t\t\tconst n = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\tfor ( let j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );\n\t\t\t\t\t\tlist.push( result[ 0 ] );\n\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].type, little_endian );\n\t\t\t\t\telement[ properties[ i ].name ] = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn [ element, read ];\n\n\t\t}\n\n\t\tfunction parseBinary( data, header ) {\n\n\t\t\tconst buffer = createBuffer();\n\n\t\t\tconst little_endian = ( header.format === 'binary_little_endian' );\n\t\t\tconst body = new DataView( data, header.headerLength );\n\t\t\tlet result, loc = 0;\n\n\t\t\tfor ( let currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\n\n\t\t\t\tfor ( let currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {\n\n\t\t\t\t\tresult = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );\n\t\t\t\t\tloc += result[ 1 ];\n\t\t\t\t\tconst element = result[ 0 ];\n\n\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\t//\n\n\t\tlet geometry;\n\t\tconst scope = this;\n\n\t\tif ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst text = LoaderUtils.decodeText( new Uint8Array( data ) );\n\t\t\tconst header = parseHeader( text );\n\n\t\t\tgeometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );\n\n\t\t} else {\n\n\t\t\tgeometry = parseASCII( data, parseHeader( data ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nexport { PLYLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}